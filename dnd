#!/usr/bin/env python3
import json
import random
import os
import time
import sys

##################################################################
# CONFIG, GLOBALS
attribs_ordered = ('str','int','wis','dex','con','chr')
default_character = {   'attribs':{},
                        'name':'Default Name',
                        'level':1,
                        'race':'Human',
                        'class': 'Fighter',
                        'hp': 1,
                        'HD': 'd6',
                        'alignment': 'True Neutral',
                        'money': {
                            'pp': 0,
                            'ep': 0,
                            'gp': 100,
                            'sp': 0,
                            'cp': 0,
                        },
                        'inventory' : [],

                        'sex':'Male',
                        'height': '5 ft. 10 in.',
                        'hair': 'brown',
                        'age': 19,
                        'home_town': 'Greyhawk',
                        'notes': '',
                        'adventure_log': [],
                        'SHD' : '1d6',
                    }

if os.name == 'nt':
    datadir = os.environ['LOCALAPPDATA' if os.name == 'nt' else 'HOME'] + '\\dnd'
else:
    datadir = os.environ['LOCALAPPDATA' if os.name == 'nt' else 'HOME'] + '/.dnd'

roster = []
DEBUG = True
config = {}
sleep_time = 0.45
defconfig = """{
    "rolls" : [
        "3d6",
        "1d12 + 6",
        "2d6 + 6"
    ],
    "default_attrib_roll_method" : 0,
    "sleep_time": 0.4
}
"""
# data sheets to load
equipment = {}
character = {}
world = {}

menu = """First Edition Dungeons & Dragons Character Management Tool.
Options are:
 (L) List Characters
 (E) Edit a Character
 (C) Create a New Character
 (S) Shop at the Store
 (G) Randomly Generate Character
 (D) Delete a Character
 (R) Configure Roll Methods
 (Q) Quit
Your Selection> """



##################################################################
# METHODS & CLASSES
def dprint( s ):
    if DEBUG is True:
        print( 'DEBUG: {}'.format(s) )

# money helper methods
def currency_base( it, quantity, ot ):
    io = world['exchange_rate'][it][ot]
    return io * int(quantity)

def frac_coin( money, kind='gp' ):
    tot = 0
    for t in ('cp','sp','gp','ep','pp'):
        if t in money:
            tot = tot + currency_base( t, money[t], kind )
    return tot

def make_change( mine, cost ):
    """ - cost names a cost in an arbitrary coin value.
        - mine names the coins I have.
        - returns False if I don't have enough
        X otherwise, spends the minimum number of coins I have,
            and tries to spend the lower denominations first,
            returning the change left.
        - wasn't able to do the method where I expend the least amount
            of coins from my person. Instead, I convert everything to cp,
            which is the finest granlarity and not fractional, then do the
            difference, then build my change up out of that out of a fresh pile
            of coins
    """
    me = frac_coin( mine, 'cp' )
    yu = frac_coin( cost, 'cp' )

    if me < yu:
        return False

    cp_change = me - yu
    change = {}

    # from largest to smallest
    cp_vals = [{'n':v,'v':frac_coin({v:1}, 'cp')} for v in ('pp','ep','gp','sp','cp')]
    for cp_value in cp_vals:
        debit = cp_change // cp_value['v']
        if debit > 0:
            change[ cp_value['n'] ] = debit
            cp_change = cp_change - cp_value['v'] * debit

    return change

def money_toString( o ):
    s = '('
    for t in ('cp','sp','gp','ep','pp'):
        if o.get(t):
            s += '{}: {}, '.format(t,o[t])
    s = s.rstrip()
    if s[-1] == ',':
        s = s[:-1]
    s = s + ') = {}'
    return s.format(frac_coin(o))

class Money:
    def __init__(self, obj=False):
        if obj:
            self.money = obj
        else:
            self.money = {}

    def me_and_you(self, rhs):
        me = frac_coin(self.money)
        if type(rhs) is Money:
            rhs = rhs.money
        yu = frac_coin(rhs)
        return me, yu

    def __lt__(self, rhs):
        me, yu = self.me_and_you( rhs )
        return me < yu

    def __gt__(self, rhs):
        me, yu = self.me_and_you( rhs )
        return me > yu

    def __eq__(self, rhs):
        me, yu = self.me_and_you( rhs )
        return me == yu

    def __le__(self, rhs):
        me, yu = self.me_and_you( rhs )
        return me <= yu

    def __ge__(self, rhs):
        me, yu = self.me_and_you( rhs )
        return me >= yu

    # a - b
    def __sub__(self, rhs):
        # break money into change?
        pass

def number_end( num ):
    if num > 10 and num < 20:
        return str(num) + 'th'
    s = str(num)
    o = str(num)[-1]
    if o == '1':
        return s + 'st'
    elif o == '2':
        return s + 'nd'
    elif o == '3':
        return s + 'rd'
    else:
        return s + 'th'

def list_dir(d):
    files=[]
    def _ld(d,files):
        if os.path.isfile(d):
            files.append(d)
        elif os.path.isdir(d):
            for x in os.listdir(d):
                _ld(os.path.join(d,x), files)
    _ld(d,files)
    return sorted(files)

def get_character_for_name( name ):
    for r in roster:
        if r.data['name'] == name:
            return r
    return False

def fmt_item( item ):
    name = [k for k in item.keys()][0]

    s = '"{}", '.format( name )

    for k, v in item[name].items():
        s = s + '{} {}, '.format( k, v )

    return s.rstrip()[:-1]


class RandomDiceRoller:
    def dn(s, n):
        return random.randint(1,n)
    def d4(s):
        return s.dn(4)
    def d6(s):
        return s.dn(6)
    def d8(s):
        return s.dn(8)
    def d10(s):
        return s.dn(10)
    def d12(s):
        return s.dn(12)
    def d20(s):
        return s.dn(20)
    def d100(s):
        return s.dn(100)
    def xdx( self, idi ): # takes a string in the format <int>d<int>, eg. 3d6, 6d4,
        nums = idi.split('d')
        if not nums[0]:
            nums[0] = 1
        i = 0
        t = 0
        d = int(nums[1])
        while i < int(nums[0]):
            t = t + self.dn( d )
            i = i + 1
        return t

    def roll( self, inp ): # computes string of N rolls of xdx joined by '+'. Can also do XDX + CONST
        total = 0
        rolls = inp.replace(' ','').split('+')
        for roll in rolls:
            val = self.xdx( roll ) if 'd' in roll else int(roll)
            total = total + val
        return total

    def mult( self, inp ): # expects the form: "xdx x INT"
        rolls = inp.replace(' ','').split('x')
        total = self.xdx( rolls[0] )
        total = total * int(rolls[1])
        return total


class RollingChart:
    pass

def getint( text ):
    val = input( text )
    return int( val )

def yn( text ):
    val = input( '{} [y/N]: '.format(text) )
    return val == 'y' or val == 'Y'

def ynq( text, default_action='n' ):
    suffix = '[';
    for letter in ('y','n','q'):
        if letter.upper() == default_action.upper():
            suffix += letter.upper() + '/'
        else:
            suffix += letter.lower() + '/'
    suffix = suffix[:-1] + ']'

    val = input( '{} {}: '.format(text, suffix) )

    if not val or len(val) == 0:
        return {'y':True,'n':False,'q':None}.get(default_action.lower(),False)

    if val == 'Q' or val == 'q':
        return None
    return val == 'y' or val == 'Y'

def fmt_attrib( attribs ):
    s = ''
    for a in attribs_ordered:
        s += '{}: {}, '.format( a, attribs[a] )
    return s.rstrip()[:-1]

class CharacterSheet:
    def __init__( self, blob = False ):
        self.data = blob if blob is not False else default_character

    def __getitem__( self, index ):
        return self.data[ index ]

    def save( self ):
        # write to disk
        with open( datadir + '/characters/' + self.data['name'], 'w' ) as f:
            f.write( json.dumps( self.data, indent = 2 ) )
        # update roster
        global roster
        for c in roster:
            if c.data['name'] == self.data['name']:
                c.data = self.data
                return
        roster.append( self )

    def load( self ):
        pass

    def LevelName( self ):
        class_names = character['classes']
        if self.data['class'] in class_names:
            if self.data['level'] >= len( class_names[ self.data['class'] ]['names'] ):
                return class_names[ self.data['class'] ]['names'][-1] + ' (' + number_end( self.data['level'] ) + ' Level)'
            else:
                return class_names[ self.data['class'] ]['names'][ self.data['level'] - 1 ]
        return self.data.get( 'class' )

    def fmt_attrib( self ):
        return fmt_attrib( self.data['attribs'] )

    def short_attrib( self ):
        attribs = self.data['attribs']
        s = ''
        for a in attribs_ordered:
            s += '{}, '.format( attribs[a] )
        return s.rstrip()[:-1]

    def print( self ):
        print( self.toString() )

    def toString( self ):
        race = self.data['race']
        if race in character['races']:
            race = character['races'][ race ]['pl']
        # Barney the Prestidigitator, Lv 1 Fighter: 16 14 13 12 16 12, ( 144 gp )
        return '"{}" the {}, Lv {} {} {}: {}'.format( self.data['name'], self.LevelName(), self.data['level'], race, self.data['class'], self.short_attrib() )

    def gen_character_sheet( self ):
        d = self.data
        race = d['race']
        if race in character['races']:
            race = character['races'][ race ]['pl']
        s = '\n "{}" the {}, Lv {} {} {}\n\n'.format( d['name'], self.LevelName(), d['level'], race, d['class'] )
        for a in attribs_ordered:
            s += '  {}: {}\n'.format( a.upper(), d['attribs'][a] )
        if d['inventory']:
            s += '\n Inventory:\n'
        for item in d['inventory']:
            if type(item) is type({}):
                item = fmt_item( item )
            s += ' - {}\n'.format( item )
        return s


def ensure_datadir():
    if not os.path.exists(datadir):
        os.mkdir( datadir )
    if not os.path.exists(datadir+'/characters'):
        os.mkdir( datadir+'/characters' )
    if not os.path.exists( datadir + '/config' ):
        with open( datadir + '/config', 'w' ) as f:
            f.write( defconfig )

def read_config():
    global config
    global sleep_time
    with open( datadir + '/config', 'r' ) as f:
        config = json.loads(f.read())
    sleep_time = config.get('sleep_time', sleep_time)

def write_config():
    with open( datadir + '/config', 'w' ) as f:
        f.write( json.dumps( config, indent=2 ) )

def load_roster():
    global roster
    character_filepaths = list_dir( datadir + '/characters' )
    for path in character_filepaths:
        with open( path, 'r' ) as f:
            roster.append( CharacterSheet( json.load(f) ) )


def SubMenu( options, header='', prompt='select>', random_noprompt=False, return_obj=False, custom=False ):
    """ takes a list,
        X prints a header
        X prints an arbitary length list of options
        - handles console window height run-overs
        X adds on: e) exit menu, q) quit to main, c) custom input
        X print a 'prompt> '
        X gets input, checks for int or option, loops until exit-condition is met,
            returns a string
        - enums, so the caller knows if it is supposed to return
        - handles different behaviors, so that all the character class
            eventualities are handled
        - takes 'random=1', so that prompt is skipped and random number
            is selected
        - can be reused in CREATOR, EDITOR, AUTO-GENERATOR
    """
    while True:
        if header:
            print( header )
        for i, option in enumerate(options):
            if type(option) is type({}):
                option = fmt_item( option )
            print( ' {}: "{}"'.format(i, option) )
        print( '\n e] exit to previous menu' )
        print( ' q] quit to main menu' )
        if custom:
            print( ' c] enter custom type' )

        if prompt[-1] != ' ':
            prompt = '{} '.format(prompt)

        s = input( prompt )

        if custom and s == 'c':
            while True:
                txt = input( 'enter custom> ' )
                if txt:
                    if txt == 'e':
                        return False
                    elif txt == 'q':
                        return None
                    return txt

        if s == 'e':
            return False
        elif s == 'q':
            return None
        else:
            try:
                iv = int(s)
            except:
                print( 'invalid selection' )
                continue
            if iv < 0 and iv >= len(options):
                print( 'invalid selection' )
                continue
            return options[ iv ]


def create_character():
    """This is the primary interface that allows a player to roll, generate, or manually enter in a character"""
    char = CharacterSheet()
    attribs = char.data['attribs']
    d = char.data
    dice = RandomDiceRoller()

    # NAME
    while True:
        ans = input( "What is your character's name? " )
        hmm = ynq( 'Character\'s Name is: "{}", keep? '.format(ans), 'y' )
        if hmm is None:
            return False
        if hmm:
            break
    char.data['name'] = ans
    print( 'Name: "{}"'.format(d['name']), end='\n\n' )
    time.sleep( sleep_time )

    # ATTRIBUTES
    auto_roll = ynq( 'Would you like your attributes to be rolled for you?', 'y' )
    if auto_roll is None:
        return
    if not auto_roll:
        while True:
            print( "Enter Attributes Manually:" )
            for a in attribs_ordered:
                attribs[a] = getint( "Enter {}: ".format(a) )
            ans = ynq( 'entered: {}, keep? '.format( fmt_attrib( attribs ) ), 'n' )
            if ans is None:
                return False
            if ans:
                break
    else:
        roll_method = config['rolls'][ config['default_attrib_roll_method'] ]
        while True:
            print( 'Rolling automatically using dice method: "{}"'.format( roll_method ) )
            for a in attribs_ordered:
                attribs[a] = dice.roll( roll_method )
            print( 'rolled: {}'.format( fmt_attrib( attribs ) ) )
            ans = ynq( 'keep?', 'n' )
            if ans is None:
                return False
            if ans:
                break
    print( 'Using attributes: {}'.format( fmt_attrib( attribs ) ) )
    time.sleep( sleep_time )

    # RACE
    while True:
        ans = SubMenu( list( character['races'].keys() ), "Select a race: ", custom=True )
        if ans is None:
            return False
        if ans is not False:
            break
    d['race'] = ans
    print( 'selected: "{}"'.format( d['race'] ), end='\n\n' )
    time.sleep( sleep_time )

    # SEX
    while True:
        ans = SubMenu( ['Male', 'Female'], 'What Sex are They [Male or Female]?', custom=True )
        if ans is None:
            return False
        if ans is not False:
            break
    d['sex'] = ans
    print( 'got sex: "{}"'.format( d['sex'] ), end='\n\n' )
    time.sleep( sleep_time )

    # ALIGNMENT
    while True:
        ans = SubMenu( character['alignments'], 'What Alignment is "{}"? '.format(d['name']), custom=True )
        if ans:
            break
        if ans is None:
            return False
    d['alignment'] = ans
    print( 'got alignment: "{}"'.format( d['alignment'] ), end='\n\n' )
    time.sleep( sleep_time )

    # CLASS
    while True:
        ans = SubMenu( sorted( list( character['classes'].keys() ) ), 'select a class', custom=True )
        if ans:
            break
        if ans is None:
            return False
    d['class'] = ans
    print( 'got class: "{}"'.format( d['class'] ), end='\n\n' )
    time.sleep( sleep_time )

    # ENTER LEVEL
    ans = input( 'What level is "{}" (default: 1)> '.format(d['name']) )
    if ans:
        d['level'] = int(ans)
    print( 'got "{}" level'.format( number_end( d['level'] ) ), end='\n\n' )
    time.sleep( sleep_time )

    # DETERMINE HIT_DICE (manual only for custom class)
    if d['class'] in character['classes']:
        d['HD'] = character['classes'][ d['class'] ]['HD']
        d['SHD'] = character['classes'][ d['class'] ]['SHD']
    else:
        d['HD'] = d['SHD'] = input( 'enter hit-dice for custom class (eg. d6, 1d8, d10)> ' )

    # HIT_POINTS (roll hit dice)
    print( 'A {} uses hit-dice "{}" with starting hit-die "{}"'.format( d['class'], d['HD'], d['SHD'] ) )
    manual_enter_hp = not ynq( 'Would you like your hit-points to be rolled for you?', 'y' )
    if manual_enter_hp is None:
        return False
    if manual_enter_hp:
        d['hp'] = getint( 'enter hitpoints rolled> ' )
    else:
        while True:
            hp = []
            hp.append( dice.roll( d['SHD'] ) )
            i = 1
            while i < d['level']:
                hp.append( dice.roll( d['HD'] ) )
                i = i + 1
            print( 'rolled: ', end='' )
            for h in hp[:-1]:
                print( str(h) + ' +', end=' ' )
            print( '{} = {}'.format( str(hp[-1]), sum(hp) ) )
            ans = ynq( 'keep?', 'y' )
            if ans is None:
                return False
            if ans:
                d['hp'] = sum(hp)
                break
    print( '{} has {} hit points'.format( d['class'], d['hp'] ), end='\n\n' )
    time.sleep( sleep_time )

    # AGE
    # sub Dwarf for non-standard character race
    ans = ynq( 'Would you like {}\'s age rolled for you?'.format(d['name']), 'y' )
    if ans:
        race = d['race'] if d['race'] in character['races'] else 'Dwarf'
        # use Cleric as default for non-book classes
        className = d['class'] if d['class'] in character['classes'] else 'Cleric'
        if race != 'Human':
            # demi-humans only have tables by super-class
            className = character['subclass-membership'][ className ]
        dieroll = character['starting-age'][race][className]
        while True:
            years = dice.roll( dieroll )
            ans = ynq( 'An {} rolls "{}" for {} years starting age, keep?'.format(d['race'], dieroll, years ), 'y' )
            if ans is None:
                return
            if ans:
                d['age'] = years
                break
    else:
        d['age'] = getint( 'Enter {}\'s age in years? '.format(d['name']) )
    print( 'character is {} years old'.format( d['age'] ), end='\n\n' )
    time.sleep( sleep_time )


    # STARTING MONEY
    ca = character['classes'][ d['class'] ]
    while True:
        print( 'Class: {} starts with "{} gp"'.format( d['class'], ca['starting_money'] ) )
        gp = dice.mult( ca['starting_money'] )
        ans = ynq( ' rolled {} gp, keep? '.format( gp ), 'y' )
        if ans is None:
            return
        if ans:
            d['money'] = {'cp':0,'sp':0,'gp':gp,'ep':0,'pp':0}
            break
    print( 'character got {} gp'.format( gp ), end='\n\n' )
    time.sleep( sleep_time )


    # WEAPON PROFICIENCIES
    #   choose N from equipment list, or write in

    # KNOWN SPELLS
    #   calculate/allot spells/choose from PHB

    # SELECT GOD
    #   write-in for now

    # HEIGHT & WEIGHT

    # KNOWN LANGUAGES

    # NON-WEAPON-PROFICIENCIES

    # FAMILY BACKGROUND

    # NEXT OF KIN

    # HOME CITY

    #--------------------
    # note race modifiers
    # note saving throws
    # note class modifiers
    # note proficiency modifiers
    #--------later-------
    # EQUIP CHARACTER
    # ARMOR CLASS (calculated on equip automatically)
    # GEAR WEIGHT (calculated on equip automatically)
    # BASE MOVEMENT RATE (calculated on gear weight change)
    #--------------------
    return char


def autogen_character():
    """this creates an entire character, completely randomly, including name"""
    char = CharacterSheet()
    attribs = char.data['attribs']
    dice = RandomDiceRoller()
    for a in attribs_ordered:
        attribs[a] = dice.roll( config['rolls'][ config['default_attrib_roll_method'] ] )
    char.data['name'] = input( "Enter the character name: " )
    return char

def shop_at_the_store():
    while True:
        name = SubMenu( sorted([r.data['name'] for r in roster]) , "Who will enter the store?", custom=False )
        if not name:
            return
        char = get_character_for_name( name )
        if not char:
            print( 'couldn\'t find {}'.format(name) )
            return

        while True:
            print( '{} has {}'.format( char['name'], money_toString( char['money'] ) ) )
            etype = SubMenu( sorted(equipment.keys()), 'What category would you like to peruse?', custom=False )
            if etype is None:
                return
            elif etype is False:
                break

            while True:
                player_money = '{} has {}'.format( char['name'], money_toString( char['money'] ) )
                #item_name = SubMenu( sorted(equipment[etype].keys()), player_money+"\nShopkeeper has these for sale. Which would you like to purchase?", custom=False )
                item = SubMenu( [{ k: v } for k, v in equipment[etype].items()], player_money+"\nShopkeeper has these for sale. Which would you like to purchase?", custom=False )
                if item:
                    item_name = [k for k in item.keys()][0]
                    subitem = item[item_name]
                    amt, kind = subitem['cost'].split(' ')
                    print( '"{}" costs {}'.format( item_name, subitem['cost'] ) )
                    print( '{} has {}'.format( char['name'], money_toString( char['money'] ) ) )
                    change = make_change( char['money'], {kind:amt} )
                    if not change:
                        print('\nYou do not have enough for that!\n')
                        continue
                    confirm = ynq( 'Are you sure you want to buy "{}"? '.format(item_name), 'y' )
                    if config is None:
                        return
                    if not confirm:
                        continue
                    char.data['money'] = change
                    char['inventory'].append(item)
                    char.save()
                    print( '\nYou bought a "{}"!\n'.format( item_name ) )
                    print( 'Change left: '.format( money_toString(change) ) )
                elif item is None:
                    return
                else:
                    break


def delete_character_menu():
    global roster
    print('')
    def print_names():
        print('Pick a character to DELETE:')
        for i, character in enumerate(roster):
            print( ' {}: "{}"'.format( i, character.toString() ) )
        print( '\n e] exit back to main menu' )
    while True:
        if len(roster) == 0:
            print( 'Character roster empty' )
            break
        print_names()
        inp = input( 'select> ' )
        if inp == 'e':
            break
        try:
            ival = int(inp)
        except:
            print( 'bad option, not integer' )
            continue
        hmm = yn( 'delete character "{}", are you sure?'.format(roster[ival].data['name']) )
        if not hmm:
            print( 'ok, not deleting. good choice' )
            continue
        name = roster[ival].data['name']
        print( 'deleting "{}"...'.format(roster[ival].data['name']) )
        roster = roster[:ival] + roster[ival+1:]
        os.unlink( datadir + '/characters/' + name )

def configure_rolling_method():
    global config
    def print_menu():
        print( 'stored attribute rolling methods:' )
        for i, r in enumerate(config['rolls']):
            d = 'default' if i == config['default_attrib_roll_method'] else ''
            print( " {}: '{}' {}".format( i, r, d ) )
        print( '\n n] add a new method' )
        print( ' d] delete a method' )
        print( ' s] set default' )
        print( ' e] exit to the main menu' )
    while True:
        if len(config['rolls']) == 0:
            print( 'Warning: No stored roll method available. Could cause errors.' )
            break
        print_menu()
        o = input( 'select> ' )
        if o == 'e':
            break
        if o == 'n':
            m = input( 'new roll method: ' )
            config['rolls'].append(m)
            write_config()
        elif o == 'd':
            i = getint( 'delete which roll method? ' )
            config['rolls'] = config['rolls'][:i] + config['rolls'][i+1:]
            write_config()
        elif o == 's':
            config['default_attrib_roll_method'] = getint( 'set which as default? ' )
            write_config()
        else:
            print( 'unknown selection' )

def load_data():
    fh = open( './data/phb_equipment.json', 'r' )
    global equipment
    equipment = json.load( fh )
    fh.close()

    fh = open( './data/phb_character.json', 'r' )
    global character
    character = json.load( fh )
    fh.close()

    fh = open( './data/phb_world.json', 'r' )
    global world
    world = json.load( fh )
    fh.close()

def list_characters():
    if len(roster) == 0:
        print( '\n  no characters\n' )
        time.sleep( sleep_time * 2 )
    for i, c in enumerate(roster):
        print( '{}: '.format(i), end='' )
        c.print()

def check_cmdline_args():
    args = sys.argv[1:]
    for l in ('list','-l','l'):
        if l in sys.argv[1:]:
            list_characters()
            return True
    for c in ('-c','char','character'):
        if c in args:
            try:
                iv = args.index(c) + 1
                if iv >= len(args):   # will throw
                    print( 'invalid argument' )
                    sys.exit(-1)
                iv = int(args[iv])
                if iv >= len(roster):
                    sys.exit(-3)
                print( roster[iv].gen_character_sheet() )
                return True
            except:
                print( 'invalid argument' )
                sys.exit(-2)

##################################################################
#
# entry point
#
##################################################################
ensure_datadir()
read_config()
load_roster()
load_data()

if check_cmdline_args():
    sys.exit(0)

op = ''
while op != 'q' and op != 'Q':
    op = input( menu )
    if op == 'L' or op == 'l':                      # list
        list_characters()
    elif op == 'E' or op == 'e':                    # edit
        print( 'Not Implemented' )

    elif op == 'C' or op == 'c':                    # create
        print( 'Creating a Player Character' )
        char = create_character()
        if char:
            char.save()
            print('\nCongratulations, you have created:\n  ')
            char.print()
            print('')
            time.sleep( sleep_time * 2 )

    elif op.upper() == 'S':                         # shop
        shop_at_the_store()

    elif op == 'G' or op == 'g':                    # generate
        print( 'Generating a Player Character' )
        char = autogen_character()
        char.print()
        ans = yn( 'keep this character?' )
        if ans:
            char.save()

    elif op == 'd' or op == 'D':                    # delete
        delete_character_menu()

    elif op == 'R' or op == 'r':                    # rolling method
        configure_rolling_method()

    elif op == 'Q' or op == 'q':                    # quit
        break
    else:
        print( "Command Unknown" )

print( 'goodbye' )

