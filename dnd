#!/usr/bin/env python3
import json
import random
import os
import time
import sys
import datetime

##################################################################
# CONFIG, GLOBALS
messages = []
attribs_ordered = ('str','int','wis','dex','con','chr')
default_character = {   'attribs':{},
                        'name':'Default Name',
                        'level':1,
                        'race':'Human',
                        'class': 'Fighter',
                        'hp': 1,
                        'HD': 'd6',
                        'alignment': 'True Neutral',
                        'money': {
                            'pp': 0,
                            'ep': 0,
                            'gp': 100,
                            'sp': 0,
                            'cp': 0,
                        },
                        'inventory' : [],

                        'sex':'Male',
                        'height': '5 ft. 10 in.',
                        'hair': 'brown',
                        'age': 19,
                        'home_town': 'Greyhawk',
                        'notes': '',
                        'adventure_log': [],
                        'SHD' : '1d6',
                    }

# directories
if os.name == 'nt':
    datadir = os.environ['LOCALAPPDATA' if os.name == 'nt' else 'HOME'] + '\\dnd'
else:
    datadir = os.environ['LOCALAPPDATA' if os.name == 'nt' else 'HOME'] + '/.dnd'
logfile_path = datadir + '/dndman.log'
log_fh = False

roster = []
DEBUG = True
config = {}
sleep_time = 0.45
msg_time = 0.6
defconfig = """{
    "rolls" : [
        "3d6",
        "1d12 + 6",
        "2d6 + 6",
        "4d6 drop lowest"
    ],
    "default_attrib_roll_method" : 0,
    "sleep_time": 0.45,
    "msg_time" : 0.6
}
"""

# data sheets to load
equipment = {}
character = {}
world = {}

main_menu_string = """First Edition Dungeons & Dragons Character Management Tool.
Options are:
 (L) List Characters
 (C) Create a New Character
 (E) Edit a Character
 (G) Generate Character Randomly
 (D) Delete a Character
 (R) Roll Methods
 (Q) Quit
Your Selection> """



##################################################################
# METHODS & CLASSES
def timestamp():
    return datetime.datetime.fromtimestamp(time.time()).strftime('%Y-%m-%d %H:%M:%S')

def open_logfile():
    global log_fh
    log_fh = open( logfile_path, 'a' )

def log( msg ):
    log_fh.write( msg )

def Message( s ):
    s = s.rstrip().lstrip()
    fmt = {'ts': timestamp(), 'msg': s} 
    global messages
    messages.append( fmt )
    print( '\n -> {}\n'.format(s) )
    log( json.dumps(fmt) )
    time.sleep( msg_time )

def vowel( l ):
    l = l.replace(' ','').lower()
    return l == 'a' or l == 'e' or l == 'i' or l == 'o' or l == 'u'

def dprint( s ):
    if DEBUG is True:
        print( 'DEBUG: {}'.format(s) )

# money helper methods
def currency_base( it, quantity, ot ):
    io = world['exchange_rate'][it][ot]
    return io * int(quantity)

def frac_coin( money, kind='gp' ):
    tot = 0
    for t in ('cp','sp','gp','ep','pp'):
        if t in money:
            tot = tot + currency_base( t, money[t], kind )
    return tot

def make_change( mine, cost ):
    """ - cost names a cost in an arbitrary coin value.
        - mine names the coins I have.
        - returns False if I don't have enough
        X otherwise, spends the minimum number of coins I have,
            and tries to spend the lower denominations first,
            returning the change left.
        - wasn't able to do the method where I expend the least amount
            of coins from my person. Instead, I convert everything to cp,
            which is the finest granlarity and not fractional, then do the
            difference, then build my change up out of that out of a fresh pile
            of coins
    """
    me = frac_coin( mine, 'cp' )
    yu = frac_coin( cost, 'cp' )

    if me < yu:
        return False

    cp_change = me - yu
    change = {}

    # from largest to smallest
    cp_vals = [{'n':v,'v':frac_coin({v:1}, 'cp')} for v in ('pp','ep','gp','sp','cp')]
    for cp_value in cp_vals:
        debit = cp_change // cp_value['v']
        if debit > 0:
            change[ cp_value['n'] ] = debit
            cp_change = cp_change - cp_value['v'] * debit

    return change

def money_toString( o ):
    s = '('
    for t in ('cp','sp','gp','ep','pp'):
        if o.get(t):
            s += '{}: {}, '.format(t,o[t])
    s = s.rstrip()
    if s[-1] == ',':
        s = s[:-1]
    s = s + ') = {}gp'
    return s.format(frac_coin(o))

class Money:
    def __init__(self, obj=False):
        if obj:
            self.money = obj
        else:
            self.money = {}

    def me_and_you(self, rhs):
        me = frac_coin(self.money)
        if type(rhs) is Money:
            rhs = rhs.money
        yu = frac_coin(rhs)
        return me, yu

    def __lt__(self, rhs):
        me, yu = self.me_and_you( rhs )
        return me < yu

    def __gt__(self, rhs):
        me, yu = self.me_and_you( rhs )
        return me > yu

    def __eq__(self, rhs):
        me, yu = self.me_and_you( rhs )
        return me == yu

    def __le__(self, rhs):
        me, yu = self.me_and_you( rhs )
        return me <= yu

    def __ge__(self, rhs):
        me, yu = self.me_and_you( rhs )
        return me >= yu

    # a - b
    def __sub__(self, rhs):
        # break money into change?
        pass

def number_end( num ):
    if num > 10 and num < 20:
        return str(num) + 'th'
    s = str(num)
    o = str(num)[-1]
    if o == '1':
        return s + 'st'
    elif o == '2':
        return s + 'nd'
    elif o == '3':
        return s + 'rd'
    else:
        return s + 'th'

def list_dir(d):
    files=[]
    def _ld(d,files):
        if os.path.isfile(d):
            files.append(d)
        elif os.path.isdir(d):
            for x in os.listdir(d):
                _ld(os.path.join(d,x), files)
    _ld(d,files)
    return sorted(files)

def get_character_for_name( name ):
    for r in roster:
        if r.data['name'] == name:
            return r
    return False

def fmt_item( item ):
    name = [k for k in item.keys()][0]

    s = '"{}", '.format( name )

    for k, v in item[name].items():
        s = s + '{} {}, '.format( k, v )

    return s.rstrip()[:-1]


class RandomDiceRoller:
    def dn(s, n):
        return random.randint(1,n)
    def d4(s):
        return s.dn(4)
    def d6(s):
        return s.dn(6)
    def d8(s):
        return s.dn(8)
    def d10(s):
        return s.dn(10)
    def d12(s):
        return s.dn(12)
    def d20(s):
        return s.dn(20)
    def d100(s):
        return s.dn(100)

    def xdx( self, idi, separate=False ): # takes a string in the format <int>d<int>, eg. 3d6, 6d4,
        nums = idi.split('d')
        if not nums[0]:
            nums[0] = 1

        t = []
        d = int(nums[1])
        for _ in range( int(nums[0]) ):
            t.append( self.dn( d ) )

        return t if separate else sum(t)

    def roll( self, inp ): # computes string of N rolls of xdx joined by '+'. Can also do XDX + CONST
        drop_lowest = False
        if 'drop lowest' in inp:
            drop_lowest = True
            inp = inp.replace('drop lowest','')

        rolls = inp.replace(' ','').split('+')
        dice_totals = []
        for roll in rolls:
            val = self.xdx( roll, separate=True ) if 'd' in roll else int(roll)
            if type(val) is int:
                dice_totals.append(val)
            else:
                dice_totals.extend(val)

        if drop_lowest:
            dice_totals.remove( min(dice_totals) )
        return sum(dice_totals)

    def mult( self, inp ): # expects the form: "xdx x INT"
        rolls = inp.replace(' ','').split('x')
        total = self.xdx( rolls[0] )
        total = total * int(rolls[1])
        return total


class RollingChart:
    pass

def getint( text ):
    if text[-1] != ' ':
        text = '{} '.format( text )
    val = input( text )
    try:
        i = int( val.lstrip().rstrip() )
        return i
    except:
        return False

def yn( text ):
    val = input( '{} [y/N]: '.format(text) )
    return val == 'y' or val == 'Y'

def ynq( text, default_action='n' ):
    suffix = '[';
    for letter in ('y','n','q'):
        if letter.upper() == default_action.upper():
            suffix += letter.upper() + '/'
        else:
            suffix += letter.lower() + '/'
    suffix = suffix[:-1] + ']'

    val = input( '{} {}: '.format(text, suffix) )

    if not val or len(val) == 0:
        return {'y':True,'n':False,'q':None}.get(default_action.lower(),False)

    if val == 'Q' or val == 'q':
        return None
    return val == 'y' or val == 'Y'

def fmt_attrib( attribs ):
    s = ''
    for a in attribs_ordered:
        s += '{}: {}, '.format( a, attribs[a] )
    return s.rstrip()[:-1]

class CharacterSheet:
    def __init__( self, blob = False ):
        self.data = blob if blob is not False else default_character

    def __getitem__( self, index ):
        return self.data[ index ]

    def save( self ):
        # write to disk
        with open( datadir + '/characters/' + self.data['name'], 'w' ) as f:
            f.write( json.dumps( self.data, indent = 2 ) )
        # update roster
        global roster
        for c in roster:
            if c.data['name'] == self.data['name']:
                c.data = self.data
                return
        roster.append( self )

    def load( self ):
        pass

    def LevelName( self ):
        class_names = character['classes']
        if self.data['class'] in class_names:
            if self.data['level'] >= len( class_names[ self.data['class'] ]['names'] ):
                return class_names[ self.data['class'] ]['names'][-1] + ' (' + number_end( self.data['level'] ) + ' Level)'
            else:
                return class_names[ self.data['class'] ]['names'][ self.data['level'] - 1 ]
        return self.data.get( 'class' )

    def fmt_attrib( self ):
        return fmt_attrib( self.data['attribs'] )

    def short_attrib( self ):
        attribs = self.data['attribs']
        s = ''
        for a in attribs_ordered:
            s += '{}, '.format( attribs[a] )
        return s.rstrip()[:-1]

    def print( self ):
        print( self.toString() )

    def toString( self ):
        race = self.data['race']
        if race in character['races']:
            race = character['races'][ race ]['pl']
        # Barney the Prestidigitator, Lv 1 Fighter: 16 14 13 12 16 12, ( 144 gp )
        return '"{}" the {}, Lv {} {} {}: {}'.format( self.data['name'], self.LevelName(), self.data['level'], race, self.data['class'], self.short_attrib() )

    def gen_character_sheet( self ):
        d = self.data
        race = d['race']
        if race in character['races']:
            race = character['races'][ race ]['pl']
        s = '\n "{}" the {}, Lv {} {} {}\n\n'.format( d['name'], self.LevelName(), d['level'], race, d['class'] )
        for a in attribs_ordered:
            s += '  {}: {}\n'.format( a.upper(), d['attribs'][a] )
        if d['inventory']:
            s += '\n Inventory:\n'
        for item in d['inventory']:
            if type(item) is type({}):
                item = fmt_item( item )
            s += ' - {}\n'.format( item )
        return s


def ensure_datadir():
    if not os.path.exists(datadir):
        os.mkdir( datadir )
    if not os.path.exists(datadir+'/characters'):
        os.mkdir( datadir+'/characters' )
    if not os.path.exists( datadir + '/config' ):
        with open( datadir + '/config', 'w' ) as f:
            f.write( defconfig )

def read_config():
    global config
    global sleep_time
    global msg_time
    with open( datadir + '/config', 'r' ) as f:
        config = json.loads(f.read())
    sleep_time = config.get('sleep_time', sleep_time)
    msg_time = config.get('msg_time', msg_time)

def write_config():
    with open( datadir + '/config', 'w' ) as f:
        f.write( json.dumps( config, indent=2 ) )

def load_roster():
    global roster
    character_filepaths = list_dir( datadir + '/characters' )
    for path in character_filepaths:
        with open( path, 'r' ) as f:
            roster.append( CharacterSheet( json.load(f) ) )


def SubMenu( options, header='', prompt='select>', random_noprompt=False, return_obj=False, custom=False, default=False, exit=True, quit=True ):
    """ takes a list,
        X prints a header
        X prints an arbitary length list of options
        - handles console window height run-overs
        X adds on: e) exit menu, q) quit to main, c) custom input
        X print a 'prompt> '
        X gets input, checks for int or option, loops until exit-condition is met,
            returns a string
        - enums, so the caller knows if it is supposed to return
        - handles different behaviors, so that all the character class
            eventualities are handled
        - takes 'random=1', so that prompt is skipped and random number
            is selected
        - can be reused in CREATOR, EDITOR, AUTO-GENERATOR
    """
    while True:
        if header:
            print( header )
        for i, option in enumerate(options):
            if type(option) is type({}):
                option = fmt_item( option )
            print( ' {}: "{}"'.format(i, option) )
        print( '' )
        if exit:
            print( ' e] exit to previous menu' )
        if quit:
            print( ' q] quit to main menu' )
        if custom:
            print( ' c] enter custom type' )

        prompt = prompt.rstrip()
        if default:
            prompt = prompt.replace('>', ' (default: {})>'.format(default) )

        if prompt[-1] != ' ':
            prompt = '{} '.format(prompt)

        # get the input
        s = input( prompt ).rstrip().lstrip()

        if custom and s == 'c':
            while True:
                txt = input( 'enter custom> ' )
                if txt:
                    if txt == 'e':
                        return False
                    elif txt == 'q':
                        return None
                    return txt

        if s == 'e':
            return False
        elif s == 'q':
            return None
        else:
            if not s:
                return default
            try:
                iv = int(s)
            except:
                print( 'invalid selection' )
                time.sleep( sleep_time )
                continue
            if iv < 0 and iv >= len(options):
                print( 'invalid selection' )
                time.sleep( sleep_time )
                continue
            return options[ iv ]


def create_character():
    """This is the primary interface that allows a player to roll, generate, or manually enter in a character"""
    char = CharacterSheet()
    attribs = char.data['attribs']
    d = char.data
    dice = RandomDiceRoller()

    # NAME
    while True:
        ans = input( "What is your character's name? " )
        if not ans:
            print( "empty string invalid" )
            continue
        elif ans == 'q':
            return False
        hmm = ynq( 'Character\'s Name is: "{}", keep? '.format(ans), 'y' )
        if hmm is None:
            return False
        elif hmm:
            break
    char.data['name'] = ans
    Message( 'Name: "{}"'.format(d['name']) )

    # ATTRIBUTES
    while True:
        auto_roll = ynq( 'Would you like your attributes to be rolled for you?', 'y' )
        if auto_roll is None:
            return
        elif not auto_roll:
            print( "Enter Attributes Manually:" )
            for a in attribs_ordered:
                while True:
                    atr = getint( "-Enter {} ? ".format(a.upper()) )
                    if not atr:
                        print( "Bad value. Integer only." )
                        continue
                    attribs[a] = atr
                    break
            ans = ynq( 'entered: {}, keep? '.format( fmt_attrib( attribs ) ), 'y' )
            if ans is None:
                return False
            elif ans:
                break
        else:
            roll_method = config['rolls'][ config['default_attrib_roll_method'] ]
            print( 'Rolling automatically using dice method: "{}"'.format( roll_method ) )
            for a in attribs_ordered:
                attribs[a] = dice.roll( roll_method )
            print( 'rolled: {}'.format( fmt_attrib( attribs ) ) )
            ans = ynq( 'keep?', 'y' )
            if ans is None:
                return False
            elif ans:
                break
    Message( 'Character has attributes: {}'.format( fmt_attrib( attribs ) ) )

    # RACE
    while True:
        ans = SubMenu( list( character['races'].keys() ), "Select a race: ", custom=True, default='Human' )
        if ans is None:
            return False
        if ans:
            keep = ynq( 'selected: "{}", keep?'.format( ans ), 'y' )
            if keep is None:
                return False
            elif keep:
                break
    d['race'] = ans
    Message( 'Race is: "{}"'.format( d['race'] ) )

    # SEX
    while True:
        ans = SubMenu( ['Male', 'Female'], 'What Sex are They?', custom=True, default='Male' )
        if ans is None:
            return False
        if ans:
            keep = ynq( 'selected: "{}", keep?'.format( ans ), 'y' )
            if keep is None:
                return False
            elif keep:
                break
    d['sex'] = ans
    Message( 'got sex: "{}"'.format( d['sex'] ) )

    # ALIGNMENT
    while True:
        ans = SubMenu( character['alignments'], 'What Alignment is "{}"? '.format(d['name']), custom=True, default='Neutral Good' )
        if ans is None:
            return False
        if ans:
            keep = ynq( 'selected: "{}", keep?'.format( ans ), 'y' )
            if keep is None:
                return False
            elif keep:
                break
    d['alignment'] = ans
    Message( 'got alignment: "{}"'.format( d['alignment'] ) )

    # CLASS
    while True:
        ans = SubMenu( sorted( list( character['classes'].keys() ) ), 'select a class', custom=True )
        if ans is None:
            return False
        if ans:
            keep = ynq( 'selected: "{}", keep?'.format( ans ), 'y' )
            if keep is None:
                return False
            elif keep:
                break
    d['class'] = ans
    Message( 'got class: "{}"'.format( d['class'] ) )

    # ENTER LEVEL
    while True:
        ans = getint( 'What level is "{}" (default: 1)> '.format(d['name']) )
        if ans is False:
            ans = 1
        keep = ynq( 'selected: "{} Level", keep?'.format( number_end(ans) ), 'y' )
        if keep is None:
            return False
        elif keep:
            break
    d['level'] = ans
    Message( '{} is "{} level"'.format( d['name'], number_end( d['level'] ) ) )

    # DETERMINE HIT_DICE (manual only for custom class)
    if d['class'] in character['classes']:
        d['HD'] = character['classes'][ d['class'] ]['HD']
        d['SHD'] = character['classes'][ d['class'] ]['SHD']
    else:
        d['HD'] = d['SHD'] = input( 'enter hit-dice for custom class (eg. d6, 1d8, d10)> ' )

    # HIT_POINTS (roll hit dice)
    while True:
        done = False
        print( 'A {} uses hit-dice "{}" with starting hit-die "{}"'.format( d['class'], d['HD'], d['SHD'] ) )
        manual_enter_hp = not ynq( 'Would you like your hit-points to be rolled for you?', 'y' )
        if manual_enter_hp is None:
            return False
        if manual_enter_hp:
            hp = getint( 'enter hitpoints> ' )
            if not hp:
                continue
            ans = ynq( 'got: {}, keep?'.format(hp), 'y' )
            if ans is None:
                return False
            elif ans:
                d['hp'] = hp
                break
        else:
            while True:
                hp = []
                hp.append( dice.roll( d['SHD'] ) )
                i = 1
                while i < d['level']:
                    hp.append( dice.roll( d['HD'] ) )
                    i = i + 1
                print( 'rolled: ', end='' )
                for h in hp[:-1]:
                    print( str(h) + ' +', end=' ' )
                print( '{} = {}'.format( str(hp[-1]), sum(hp) ) )
                ans = ynq( 'keep?', 'y' )
                if ans is None:
                    break # here we exit to the higher loop
                if ans:
                    d['hp'] = sum(hp)
                    done = True
                    break
            if done:
                break
    Message( '{} has {} hit points'.format( d['class'], d['hp'] ) )

    # AGE
    # sub Dwarf for non-standard character race
    while True:
        done = False
        ans = ynq( 'Would you like {}\'s age rolled for you?'.format(d['name']), 'y' )
        if ans is None:
            return False
        if not ans:
            age = getint( 'Enter {}\'s age in years? '.format(d['name']) )
            if not age:
                continue
            keep = ynq( 'got {} years of age, keep?'.format(age) )
            if keep is None:
                return False
            elif keep:
                d['age'] = age
                break
        else:
            race = d['race'] if d['race'] in character['races'] else 'Dwarf'
            # use Cleric as default for non-book classes
            className = d['class'] if d['class'] in character['classes'] else 'Cleric'
            if race != 'Human':
                # demi-humans only have tables by super-class
                className = character['subclass-membership'][ className ]
            dieroll = character['starting-age'][race][className]
            while True:
                years = dice.roll( dieroll )
                ans = ynq( 'An {} rolls "{}" for {} years starting age, keep?'.format(d['race'], dieroll, years ), 'y' )
                if ans is None:
                    break # quit upwards to higher loop
                if ans:
                    d['age'] = years
                    done = True
                    break
            if done:
                break
    Message( 'character is {} years old'.format( d['age'] ) )

    # STARTING MONEY
    ca = character['classes'][ d['class'] ]
    while True:
        gp = dice.mult( ca['starting_money'] )
        ans = ynq( '{} starts with "{} gp". Rolled {} gp, keep? '.format( d['class'], ca['starting_money'], gp ), 'y' )
        if ans is None:
            return
        if ans:
            d['money'] = {'cp':0,'sp':0,'gp':gp,'ep':0,'pp':0}
            break
    Message( 'character got {} gp'.format( gp ) )


    # WEAPON PROFICIENCIES
    #   choose N from equipment list, or write in

    # KNOWN SPELLS
    #   calculate/allot spells/choose from PHB

    # SELECT GOD
    #   write-in for now

    # HEIGHT & WEIGHT

    # KNOWN LANGUAGES

    # NON-WEAPON-PROFICIENCIES

    # FAMILY BACKGROUND

    # NEXT OF KIN

    # HOME CITY

    #--------------------
    # note race modifiers
    # note saving throws
    # note class modifiers
    # note proficiency modifiers
    #--------later-------
    # EQUIP CHARACTER
    # ARMOR CLASS (calculated on equip automatically)
    # GEAR WEIGHT (calculated on equip automatically)
    # BASE MOVEMENT RATE (calculated on gear weight change)
    #--------------------
    char.save()
    Message('Congratulations, you have created:\n{}'.format( char.toString() ) ) 
    return char

def autogen_character():
    """this creates an entire character, completely randomly, including name"""
    char = CharacterSheet()
    attribs = char.data['attribs']
    dice = RandomDiceRoller()
    for a in attribs_ordered:
        attribs[a] = dice.roll( config['rolls'][ config['default_attrib_roll_method'] ] )
    char.data['name'] = input( "Enter the character name: " )
    return char

def shop_at_the_store( char ):
    while True:
        print( '\n{} has {}'.format( char['name'], money_toString( char['money'] ) ) )
        etype = SubMenu( sorted(equipment.keys()), 'What category would you like to peruse?', custom=False )
        if etype is None:
            return
        elif etype is False:
            break

        while True:
            player_money = '{} has {}'.format( char['name'], money_toString( char['money'] ) )
            #item_name = SubMenu( sorted(equipment[etype].keys()), player_money+"\nShopkeeper has these for sale. Which would you like to purchase?", custom=False )
            item = SubMenu( [{ k: v } for k, v in equipment[etype].items()], player_money+"\nShopkeeper has these for sale. Which would you like to purchase?", custom=False )
            if item:
                item_name = [k for k in item.keys()][0]
                subitem = item[item_name]
                amt, kind = subitem['cost'].split(' ')
                print( '"{}" costs {}'.format( item_name, subitem['cost'] ) )
                print( '{} has {}'.format( char['name'], money_toString( char['money'] ) ) )
                change = make_change( char['money'], {kind:amt} )
                if not change:
                    print('\nYou do not have enough for that!\n')
                    continue
                confirm = ynq( 'Are you sure you want to buy "{}"? '.format(item_name), 'y' )
                if config is None:
                    return
                if not confirm:
                    continue
                char.data['money'] = change
                char['inventory'].append(item)
                char.save()
                Message( 'You bought a "{}"!\nCoins remaining: {}'.format( item_name, money_toString(change) ) )
            elif item is None:
                return
            else:
                break


def delete_character_menu():
    global roster
    print('')
    def print_names():
        print('Pick a character to DELETE:')
        for i, character in enumerate(roster):
            print( ' {}: "{}"'.format( i, character.toString() ) )
        print( '\n e] exit back to main menu' )
    while True:
        if len(roster) == 0:
            print( 'Character roster empty' )
            break
        print_names()
        inp = input( 'select> ' )
        if inp == 'e':
            break
        try:
            ival = int(inp)
        except:
            print( 'bad option, not integer' )
            continue
        hmm = yn( 'delete character "{}", are you sure?'.format(roster[ival].data['name']) )
        if not hmm:
            print( 'ok, not deleting. good choice' )
            continue
        name = roster[ival].data['name']
        print( 'deleting "{}"...'.format(roster[ival].data['name']) )
        roster = roster[:ival] + roster[ival+1:]
        os.unlink( datadir + '/characters/' + name )

def configure_rolling_method():
    global config
    def print_menu():
        print( 'stored attribute rolling methods:' )
        for i, r in enumerate(config['rolls']):
            d = '-' * 10 + 'default' if i == config['default_attrib_roll_method'] else ''
            print( " {}: '{}' {}".format( i, r, d ) )
        print( '\n n] add a new method' )
        print( ' d] delete a method' )
        print( ' s] set default' )
        print( ' e] exit to the main menu' )
    while True:
        if len(config['rolls']) == 0:
            print( 'Warning: No stored roll method available. Could cause errors.' )
            break
        print_menu()
        o = input( 'select> ' )
        if o == 'e' or o == 'q':
            break
        if o == 'n':
            print( 'Add New roll method.\nCan be of the types: "d20", "2d4", "3d6 + 10", "2d4 + 3d12", or "4d6 drop lowest"' )
            m = input( 'enter method> ' )
            config['rolls'].append(m)
            write_config()
        elif o == 'd':
            i = getint( 'delete which roll method? ' )
            config['rolls'] = config['rolls'][:i] + config['rolls'][i+1:]
            write_config()
        elif o == 's':
            config['default_attrib_roll_method'] = getint( 'set which as default? ' )
            write_config()
        else:
            print( 'unknown selection' )

def load_data():
    fh = open( './data/phb_equipment.json', 'r' )
    global equipment
    equipment = json.load( fh )
    fh.close()

    fh = open( './data/phb_character.json', 'r' )
    global character
    character = json.load( fh )
    fh.close()

    fh = open( './data/phb_world.json', 'r' )
    global world
    world = json.load( fh )
    fh.close()

def list_characters():
    if len(roster) == 0:
        print( '\n  no characters\n' )
        time.sleep( sleep_time * 2 )
    for i, c in enumerate(roster):
        print( ' {}: {}'.format(i, c.toString()) )

def check_cmdline_args():
    args = sys.argv[1:]
    for l in ('list','-l','l'):
        if l in sys.argv[1:]:
            list_characters()
            return True
    for c in ('-c','char','character'):
        if c in args:
            try:
                iv = args.index(c) + 1
                if iv >= len(args):   # will throw
                    print( 'invalid argument' )
                    sys.exit(-1)
                iv = int(args[iv])
                if iv >= len(roster):
                    sys.exit(-3)
                print( roster[iv].gen_character_sheet() )
                return True
            except:
                print( 'invalid argument' )
                sys.exit(-2)

def edit_inventory( char ):
        while True:
            print( '\nEditing: "{}", Inventory:'.format(char['name']) )
            if char['inventory']:
                for index, item in enumerate(char['inventory']):
                    if type(item) is type({}):
                        item = fmt_item( item )
                    print( ' {}: {}'.format( index, item ) )
            else:
                print('* no items')

            ans = input("""\n A)dd new item\n S)hop at The Players Handbook Store\n D)elete item\n Q)uit to previous menu\nselect> """)
            if ans == 'q':
                break
            elif ans == 's':
                shop_at_the_store( char )

            elif ans == 'n':
                while True:
                    item = input( 'Enter Item: ' )
                    if not item:
                        print('\nbad input (q to quit)')
                        continue
                    if item.lower() == 'q':
                        break
                    char['inventory'].append(item)
                    Message( '"{}" gets {} "{}"'.format(char['name'], 'an' if vowel(item[0]) else 'a', item) )
                    break

            elif ans == 'd':
                index = getint( 'delete which> ' )
                if index is False:
                    print( '\nskipping' )
                    continue
                if index < 0 or index >= len(char['inventory']):
                    print( '\ninvalid selection' )
                    time.sleep( sleep_time )
                    continue
                item = char['inventory'][index]
                if type(item) is type({}):
                    item = [k for k in item.keys()][0]
                char.data['inventory'] = char['inventory'][:index] + char['inventory'][index+1:]
                char.save()
                Message( '"{}" dropped "{}"'.format( char['name'], item ) )
            else:
                print('\ndo not understand command')

def edit_attributes( char ):
    print( '\nnot yet' )
    time.sleep( sleep_time )
                
def edit_character():
    while True:
        name = SubMenu( sorted([r.data['name'] for r in roster]), '\nEdit which character?', exit=False, default=None, custom=False )
        if not name:
            return

        char = get_character_for_name( name )
        if not char:
            print( '\n{} not found!'.format(name) )
            continue

        actions = [
            'Attributes',
            'Inventory'
        ]
        act = SubMenu( actions, '\nEditing "{}". Which category?'.format(name) )
        if not act:
            continue

        if act == 'Attributes':
            edit_attributes( char )
        elif act == 'Inventory':
            edit_inventory( char )

##################################################################
#
# entry point
#
##################################################################
ensure_datadir()
read_config()
load_roster()
load_data()
open_logfile()

if check_cmdline_args():
    sys.exit(0)

op = ''
while op != 'q' and op != 'Q':

    op = input( main_menu_string )

    if op.upper() == 'L':                      # list
        list_characters()

    elif op.upper() == 'E':                    # edit character
        edit_character()

    elif op.upper() == 'C':                    # create
        print( 'Creating a Player Character' )
        char = create_character()

    elif op.upper() == 'G':                    # generate
        print( 'Generating a Player Character' )
        char = autogen_character()
        char.print()
        ans = yn( 'keep this character?' )
        if ans:
            char.save()

    elif op.upper() == 'D':                    # delete
        delete_character_menu()

    elif op.upper() == 'R':                    # rolling method
        configure_rolling_method()

    elif op.upper() == 'Q':                    # quit
        break

    else:
        print( "Command Unknown" )

log_fh.close()
print( 'goodbye' )

